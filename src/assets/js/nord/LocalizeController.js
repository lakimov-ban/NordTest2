import{resolveTranslation as n,subscribe as o}from"./translation.js";import t from"./en-us.js";import"./localization.js";import"./localization2.js";import"./localization3.js";import"./localization4.js";import"./localization5.js";import"./localization6.js";import"./localization7.js";import"./localization8.js";const s=()=>{};class i{constructor(o,t={onLangChange:s}){this.host=o,this.options=t,this.handleLangChange=()=>{const o=n(this.lang);this.resolvedTranslation!==o&&(this.resolvedTranslation=o,this.options.onLangChange(),this.host.requestUpdate())},o.addController(this),this.resolvedTranslation=n(this.lang)}get lang(){return this.host.lang||document.documentElement.lang}get resolvedLang(){return this.resolvedTranslation.$lang}hostConnected(){this.unsubscribe=o(this.handleLangChange),this.options.onLangChange()}hostDisconnected(){var n;null===(n=this.unsubscribe)||void 0===n||n.call(this)}term(n,...o){var s,i;const{resolvedTranslation:a,resolvedLang:l}=this,e=this.host.localName;null==a[e]?console.warn(`NORD: Missing translations for component \`${e}\` in lang: \`${l}\``):null==a[e][n]&&console.warn(`NORD: Missing translation key \`${String(n)}\` for component \`${e}\` in lang \`${l}\``);const r=null!==(i=null===(s=a[e])||void 0===s?void 0:s[n])&&void 0!==i?i:t[e][n];return"function"==typeof r?r(...o):r}}export{i as LocalizeController};
//# sourceMappingURL=LocalizeController.js.map
